# Ethereum VM

## Об исполнении кода, предназначении виртуальной машины, работе компиляторов и прочих прелестях поднаготной программирования.

Если вы программист, пишете код и привыкли к тому что он исполняется, а вот как именно это происходит - понятия не имеете, то эта статья для вас.
Далее я опишу как происходит исполнение кода в Ethereum, но описанный процесс аналогичен и для множества других языков программирования.

Начнем по порядку. Вот мы пишем код. Все мы знаем что код исполняется процессором. Но процессором, очевидно, исполняется совсем не тот код, который мы пишем (ну если конечно писать не на ассемблере).

Исполняется "машинное представление" кода, а именно - опкоды (инструкции) процессора. За это и отвечает виртуальная машина. Когда мы пишем высокоуровневый код, мы даже не задумываемся о том на каком процессоре он собирается исполниться, как раз потому что между кодом, который мы хотим исполнить и процессором занимает место VM (Virtual Machine), которая и занимается преобразованием того что нужно исполнить в то какими именно командами это сделает процессор.

VM, однако, на вход тоже получает не исходники, а байткод.

Преобразованием исходников в байткод занимается компилятор. ~~Как велел мне написать dexaran~~ как известно хороших компиляторов в мире два: [gcc](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) и [LLVM](https://en.wikipedia.org/wiki/LLVM). Первый находится в разработке уже 35 лет, второй - всего 15. Так что если вы услышите что какая-то команда для своего проекта пишет собственный компилятор, можете себе представить какую дрянь этот компилятор будет из себя представлять и сколько примерно времени потребуется чтобы довести его до ума.

Просто преобразовывать человекочитаемые исходники в нечитаемый байткод не так уж сложно. Сложная часть работы компилятора - это оптимизация полученного байткода. Плохой компилятор генерирует плохой байткод, его много, он медленнее исполняется и все вытекающие отсюда последствия.

Так как нормальные люди для своих проектов компиляторы с нуля не пишут, то в большинстве случаев задача написать компилятор сводится к созданию front-end вашего языка программирования к LLVM. По сути дела написание "компилятора для компилятора". У компиляторов есть [ir](https://en.wikipedia.org/wiki/Intermediate_representation)(внутреннее представление / intermediate representation), с которым они и работают перед тем как создать байткод для виртуальной машины, т.е. проводят над ним оптимизацию и прочую черную магию, о которой нам вообще лучше не знать.
В случае Ethereum все осложняется тем, что используется особая виртуальная машина EthereumVM, которая и будет исполнять байткод. Чтобы научить LLVM генерировать байткод для виртуальной машины, которая изначально не поддерживается, можно написать back-end к LLVM.
На практике оказалось что проще написать для Ethereum новую виртуальную машину, к которой есть back end LLVM, чем сделать это для текущей VM.

Преобразование высокоуровневого языка программирования, такого как Solidity, в байткод происходит следующим образом: сначала язык программирования транслируется в [абстрактное синтаксическое дерево зависимостей](https://en.wikipedia.org/wiki/Abstract_syntax_tree)(ast/ abstract syntax tree), затем на основе AST происходит преобразование в ir компилятора, затем оптимизация и прочие внутренние действия компилятора, затем генерация байткода виртуальной машины, который можно подать виртуальной машине для исполнения. Такой байткод виртуальная машина может преобразовать в опкоды процессора и исполнить.

## Как в Ethereum это работает сейчас.

В данный момент имеется компилятор SOLC, который компилирует Solidity в байткод EthereumVM.

Solidity -> AST -> SOLC_ir -> SOLC optimization -> EthereumVM bytecode <-> processor op-codes

В обновлении протокола 'Metropolis' будет реализована виртуальная машина [web assembly](https://en.wikipedia.org/wiki/WebAssembly) (eWASM - версия виртуальной машины для Ethereum), для которой есть LLVM back end.

## Как будет реализовано преобразование кода Solidity после Metropolis

Solidity -> AST -> LLVM_ir -> LLVM optimization -> eWASM bytecode <-> processor op-codes
